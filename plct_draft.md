<!-- PLCT 技术报告面试讲稿 -->

## RISC-V 生态
对于 RISC-V 生态，可能在座的各位都比我熟悉，尽管这样，我想先聊一下我对 RISC-V 生态的一些看法。  
RISC-V 架构诞生于伯克利，设计之初就定位为是一种完全开源的架构，基本指令仅有 40 多条，设计简洁，模块化设计使得用户可以根据需求自由定制，配置不同的扩展指令集。  
与 X86 架构进行对比，RISC-V 架构大大降低了芯片开发的难度，并且它吸收了一些传统指令集的经验教训，抛弃了历史包裹，设计更加简洁先进。但是在高性能处理核领域，RISC-V 目前还比不上 x86。  
与 Arm 架构进行对比，RISC-V 指令集完全开源，而 Arm 需要商业授权。RISC-V 推崇大道至简的设计，架构文档只有 200 多页，而 Arm 架构文档长达数千页。但是在生态上，还需要社区开发者们的进一步努力。  
计算所的包老师有过这样一个观点，“目前很多人对 RISC-V 的质疑基本都是这两个观点，第一是碎片化无法解决，第二个是性能做不上去”。  
第二点很好理解，解决办法也很直接：基于 RISC-V 做出一个高性能处理核就行了。  
我对于第一点碎片化问题的个人理解是，由于 RISC-V 的定制化，当不同的公司不同的机构都在开发自己的处理核的时候，可能导致 IP 设计参差不齐，没有统一的标准，这样一来就会给开发带来很大额外成本。  
我觉得相比于高性能处理核领域，RISC-V 更有可能在嵌入式领域赢得市场。  
去年 12 月 26 号，我去参加全国大学生操作系统比赛研讨会，在场下和一位国内某知名芯片厂商产品经理聊了一下在嵌入式行业内，目前 RISC-V 是什么样的情况。我问，RISC-V 对比 Arm 在性能和功耗方面有什么优势吗？没有。RISC-V 在嵌入式行业火吗？很火。那位先生说 RISC-V 带来的是一个新的产业模式，一个有可能打破 Arm 商业垄断的模式。  

## RISC-V 与嵌入式
好，现在我来说一下我觉得 RISC-V 在嵌入式领域里面有哪些优势，主要是对比 Arm 架构。  
首先，在性能与功耗上，同样的芯片面积和制作工艺下，RISC-V 和 Arm 不相上下。我们可以来看张图（翻页）   
然后，在成本上，RISC-V 占据优势，具体表现为以下几个方面。一，RISC-V 的设计成本较低，得益于其简洁的设计风格。比如规整的指令结构，这样可以提高译码速度，还有简单的寄存器组成，等等。其次就是由于 RISC-V 的开源性，开发厂商可以省去一笔昂贵的版权费，同时能做到技术自主可控，我觉得这点在当前的国际大环境下特别重要。  

## Rust 语言与嵌入式
由于听说上周有同学也做了关于 Rust 语言的报告，因此这里对于 Rust 语言的部分不会讲得很深，只说一些个人看法。  
所有编程语言都有着一套管理内存的方式。这里拿比较经典的 C/C++ Java Rust 三家进行比较。  
C/C++ 的内存管理方法是：我把内存的控制权基本上都交给开发者，开发者可以定义裸指针，可以在任意内存地址写东西，至于这样做会出现什么后果，你们自己承担。  
这样的好处是正确的代码运行起来确实是很快，一般是所有编程语言里面最快的，但是裸指针满天飞，内存泄露等问题也广受诟病。  
Java 是全盘接管，它告诉开发者，内存管理就交给我好了，我帮你们清理内存垃圾。  
这样的好处是程序的安全性提高了，程序员也得以从指针地狱里面解放出来，可以花更多的精力在编写逻辑代码上。但很显然，GC 机制使得运行时扩增，程序的速度因此下降。  
而 Rust 使用的方法是：我不让你随所欲为，也不帮你做完一切，我制定一个规则，你们必须按照这个规则来编写代码，如果你们的代码能通过编译，我就可以生成又快又安全的程序。  
这是 Rust 语言的一种安全哲学。  
Rust 语言的所有权机制保证了不会出现二次释放问题，生命周期机制保证了不会出现裸指针，这两个问题是在 C/C++ 开发中常有的问题。  
因此 Rust 语言开发将 C/C++ 中的很多运行时错误转化成了编译期错误，运行时错误我们需要通过调试去 debug，而编译器错误我们只需要修改写法就行了。  
另外就是 Rust 的类型系统非常强大，利于提高开发效率。  

## Rust 语言与嵌入式
现在我们来聊一下为什么要用 Rust 语言来写嵌入式。  
我个人觉得 Rust 语言非常适合嵌入式开发，主要体现在以下几个方面：  
首先，Rust 的运行时很小，这就代表它有着极高的性能，其次，Rust 语言的独特内存管理方式保证了内存安全，这两点是嵌入式软件开发的硬需。另外 Rust 语言的所有权机制非常契合嵌入式里面的外设抽象：我们的系统里面特定的外设同一时间只有一个，类似移动语义。除此之外我们还可以通过封装对寄存器进行良好的抽象。（翻页陈述代码）  
Rust 语言的模块化和包管理在嵌入式开发里面相比 C 是一大优势，比如在嵌入式领域有个 HAL 库的概念，传统 C 语言开发的时候如果你要在自己的项目里面使用 HAL 库，你需要将一大堆源文件放到你自己的目录下，并且还要写 Makefile 对它进行管理。甚至有些时候很多开发板厂商不提供单独的 HAL 库，这样你就需要在官方提供的 SDK 环境中进行开发。而在 Rust 语言里面，你只需在配置文件里面加上一行，就可以“导入”相关的第三方库，进而省去大量的项目维护成本，提高生产效率。  
其次 Rust 的宏系统非常强大，不同于 C 语言的宏是文本替换，Rust 的宏是语法树到语法树的替换，可以达到卫生宏的效果。由于时间关系这里就不多涉及。  
开发工具方面，Rust 支持多种指令集的交叉编译链，并且有工具统一管理。  
然后更让开发者欣喜的是 Rust 异步语法，比如 async/await 关键字，在裸机环境中也能得到支持。这样子我们写嵌入式程序的时候也能写异步代码，并且 await 关键字让我们像写同步代码一样去写异步代码。  
举个例子：（陈述代码）  
接下来我想谈一下我对 Rust 嵌入式的生态的看法。首先这张图来自 Rust 嵌入式社区的资深贡献者，我的同学，洛佳。  
首先嵌入式硬件一般分为两部分，一个是处理核，比如平头哥的 C906/C910，还有 Sifive 的 U54/U74，另外一部分是外设，例如前面说到的 UART，除此之外还有 SPI，ADC 等等。处理核和外设合起来组成 SOC，这就很接近我们平常所说的开发板了，比如 k210。一个 SOC 平台的 Rust 嵌入式支持库大概有三个部分，第一个是外设访问库，这个库是可以通过给出相应板子的数据手册自动生成的;另外一个库是硬件抽象层库，在 Rust 嵌入式社区里面这个称为 embedded-hal 库，然后就是还有一些运行时库。  
外设访问库是机器生成的，里面主要是一些外设的结构体和方法，这里就不详细分析。我们先来看一下运行时库。  
运行时库这部分可以根据需求来实现，你可以写功能简单的最小运行时，也可以写能跑操作系统的复杂运行时。  
运行时库需要实现的功能主要是以下几个方面：  
首先，我们在硬件平台上运行裸机程序的时候，在运行第一行逻辑代码之前，我们需要进行一系列准备工作，这些准备工作主要是目标文件链接到指定内存地址上，设置中断入口点，提供默认的中断处理函数，跳转到逻辑代码入口。  
运行时库一般会提供一些过程宏，标记到某个函数，然后这个函数就作为逻辑代码入口点。  
可能大家这部分不能很好的理解，这里我简单的概括一下：在裸机环境上运行程序的时候，我们需要一些准备运行时环境的共性工作，而运行时库就帮我们完成了这部分工作。  
好了，运行时库的部分到这里告一段落，接下来我想介绍一下 Rust 嵌入式社区里面一个很重要的标准，叫做 embedded-hal 标准。  
什么是 embedded-hal 标准？这是 Rust 嵌入式社区的一个统一的标准，它是对外设本身的一系列抽象。这个标准对应着一个同名的库，这个库只是提供一系列的 trait,不涉及具体的实现。有些朋友可能不了解 trait 是什么，不妨把它看成是 Java 里面的接口，interface。embedded-hal 不涉及具体的实现，具体的实现则由各个开发板的实现库来实现，比如 stm32f30x-hal,k210-hal。这种设计模式其实在 Rust 里面很常见，有了这个 embedded-hal 标准，我们就有了对嵌入式外设的统一的抽象，代码的移植性和可复用性由此可以得到提高。  
不知道各位还记不记得之前给出过的这个例子（翻页），这里我们引入一个 embedded-hal 的一个 serial trait,大家可以理解为 serial 接口，而 serial 是串行的意思，因此这是一个串行数据传输接口。而我们下面的代码就是为这个 UartLite 外设实现串行数据传输接口。如果各位有上过嵌入式开发的课程或者说接触过嵌入式相关的东西，就会知道外设数据传输有串行和并行两种方式，分别对应两种外设抽象。而这里我们实现的是串行抽象。  


## Rust 语言与 RISC-V 嵌入式
感谢各位一直听到现在，接下来我的报告将进入最后一个环节：将 RISC-V 和 Rust 和嵌入式结合起来，以一个具体例子，来分析一下三者之间结合起来会有什么样的化学反应。  
首先我需要提一下 RISC-V 里面的 SBI 标准，这里我不会介绍这个标准具体细节，我想要说明的是这个标准十分有用。  
在 RISC-V 体系结构里面，从上到下分为 U, S, M 三层，分别运行着用户程序，操作系统内核，和 SBI 实现，注意，是 SBI 实现，SBI 只是一个标准，SBI 实现才是具体的软件。M 层以下就是各种硬件平台，包括模拟器和真实硬件。这种层级结构带来一个好处：如果我们想要移植一个操作系统到一个硬件平台的时候，我们只需要移植或者实现这个硬件平台的 SBI 实现，这样子操作系统内核就可以无障碍地移植到那个硬件平台上去。另外一种好处是：RISC-V 指令集版本目前还在不断迭代更新中，尽管每个版本的更改不会很大。指令集版本升级之后，可能会有些寄存器或者指令发生变化，这样就导致可能新指令集版本的软件不能兼容旧指令集版本的硬件。这时候，SBI 就派上用场了，我们可以在 SBI 实现里实现模拟指令运行，使得向下兼容指令集版本成为可能。这样一来就延长了硬件的生命周期。  
现在我来介绍一款软件，叫做 RustSBI，这是一个用 Rust 语言写的 SBI 实现。它适配 RISC-V 0.2 版本的 SBI 标准，目前支持 qemu 和 k210 平台，对类 Unix 操作系统内核有很好的支持。  
与 RustSBI 类似的实现是 OpenSBI，qemu 平台默认的 SBI 实现。  
RustSBI 一共 2000 多行代码，它实现了大部分 OpenSBI 中的功能，而 OpenSBI 一共 16000 多行代码。  
尽管 OpenSBI 适配的平台比 RustSBI 多，但除去平台相关代码它的代码量仍然是远远高于 RustSBI 的，而且 RustSBI 的平台相关代码仅有几百行。RustSBI 用少量的代码达到了很好的效果，原因在于其依赖了一些第三方库，它对 k210 的支持使用了 k210-hal 和 k210-pac 这两个嵌入式支持库，因此 RustSBI 的开发效率受益于 Rust 嵌入式生态。  
然后对于 k210 这块板子，它实现的指令集版本是 1.9 版本，而我们的编译链基本上都是 1.11 版本，这样子就会出现一些不兼容的地方，比如 sfence.vma 这条指令，在 k210 平台上是不存在的，但是它存在 sfence.vm 这条指令，因此我们可以在 SBI 实现里面模拟 sfence.vma 指令。(翻页陈述代码)  
k210 另外的一个缺陷是它没有 S 态外部中断，我们也可以通过 SBI 来解决这个问题：（陈述 ppt 和代码）  
从这个例子可以看到 SBI 的设计使得我们可以做到这种看起来不可思议的事情，并且我觉得这正是 RISC-V 架构软硬协同设计的一个很好的体现：硬件和软件互补。  
最后想要补充一点的是，RustSBI 是一个库，它本身不涉及具体实现，目前支持 qemu 和 k210 平台的代码是作者写的两个参考实现。事实上，如果我们需要将 RustSBI 适配一个新的硬件平台，只需要提供相应的 Rust 嵌入式支持库，即可很容易完成。这个得益于 Rust 语言模块化设计。  
我的演讲到此结束，谢谢各位。  

