<!-- PLCT 技术报告面试讲稿 -->

## RISC-V 生态
对于 RISC-V 生态，可能在座的各位都比我熟悉，尽管这样，我想先聊一下我对 RISC-V 生态的一些看法。  
RISC-V 架构诞生于伯克利，设计之初就定位为是一种完全开源的架构，基本指令仅有 40 多条，设计简洁，模块化设计使得用户可以根据需求自由定制，配置不同的扩展指令集。  
与 X86 架构进行对比，RISC-V 架构大大降低了芯片开发的难度，并且它吸收了一些传统指令集的经验教训，抛弃了历史包裹，设计更加简洁先进。但是在高性能处理核领域，RISC-V 目前还比不上 x86。  
与 Arm 架构进行对比，RISC-V 指令集完全开源，而 Arm 需要商业授权。RISC-V 推崇大道至简的设计，架构文档只有 200 多页，而 Arm 架构文档长达数千页。但是在生态上，还需要社区开发者们的进一步努力。  

我觉得相比于高性能处理核领域，RISC-V 更有可能在嵌入式领域赢得市场。  
去年 12 月 26 号，我去参加全国大学生操作系统比赛研讨会，在场下和一位国内某知名芯片厂商产品经理聊了一下在嵌入式行业内，目前 RISC-V 是什么样的情况。我问，RISC-V 对比 Arm 在性能和功耗方面有什么优势吗？没有。RISC-V 在嵌入式行业火吗？很火。那位先生说 RISC-V 带来的是一个新的产业模式，一个有可能打破 Arm 商业垄断的模式。  

## RISC-V 与嵌入式
好，现在我来说一下我觉得 RISC-V 在嵌入式领域里面有哪些优势，主要是对比 Arm 架构。  
首先，在性能与功耗上，同样的芯片面积和制作工艺下，RISC-V 和 Arm 不相上下。（给出数据）  
然后，在成本上，RISC-V 占据优势，具体表现为以下几个方面。一，RISC-V 的设计成本较低，得益于其简洁的设计风格。比如规整的指令结构，这样可以提高译码速度，还有简单的寄存器组成，等等。另外 RISC-V 是模块化的设计，某种程度上提高了可移植性和降低了维护成本。对于上面这句话，我个人感觉是这样，但还没有深入研究，如果各位在这方面有见解的话，欢迎提出或者指出错误。其次就是由于 RISC-V 的开源性，开发厂商可以省去一笔昂贵的版权费，同时能做到技术自主可控，我觉得这点在当前的国际大环境下特别重要。  
todo：软硬协同设计  
RISC-V 的 SBI 标准，使得移植运行在 S 态的操作系统到不同的平台，包括模拟器和硬件开发板，十分方便。关于 SBI 标准，后面会有环节来深入。现在我们先跳过。  

## Rust 语言
好，现在我们来聊一下 Rust 语言。  
可能有些同学对 Rust 语言不是很熟悉，我先来简单介绍一下这门语言的大致情况和为什么会有这门语言。  
Rust 语言是一门类似 C 的语言，它有编译期，编译生成可执行文件，并且它支持多个指令集的编译目标，比如 RISC-V。同时它的写法区别于 Java, C# 这样的完全面向对象的语言，它本身没有传统的类和对象，但有一些面向对象的特性，比如封装，即定义一个结构体，给这个结构体封装一些方法，再比如 trait 对象。  
Rust 语言被设计出来是为了解决内存安全问题，同时希望兼顾高性能。目前来说 Rust 这两者都做得比较好。  
基本上所有程序都需要管理和使用内存，在一些语言，比如 C/C++，依赖开发者亲自动手分配和释放内存;另一些语言，比如 Java,具有垃圾回收机制，在运行时中不断寻找不再使用的内存并释放掉。这两种方法各有千秋，但 Rust 语言采用的是另一种方法，那就是所有权和生命周期机制。  
所有权机制主要是指下面三条规则：一，Rust 里面每一个值都有一个被称为其所有者的变量;二，值在任一时刻有且仅有一个所有者;三，当所有者离开作用域，这个值将被丢弃。  
下面来看一段关于所有权的代码：（陈述代码）  
生命周期机制是 Rust 语言区别于其他大部分编程语言的一个概念，它主要是说明了这样一条规则：一个值的借用的生命周期不能长于该值本身的生命周期。也就是说，我们的借用不能指向一个已经被丢弃的值，这样就避免了类似 C 语言中裸指针的产生。  
下面是一段关于 Rust 中生命周期机制的代码：（陈述代码）  
或许上面这个例子还不足完整说明生命周期，我们再来看下一个例子，这段代码来自开源的 Rust 语言教程：（陈述代码）  
这个函数接收两个字符串引用参数，并返回长度较长的那个。这样的写法思路在 C/C++ 里面是完全没问题的，编译器甚至不会给出警告，而在 Rust 语言里面这段代码是无法编译的。原因在于在编译期中编译器不知道是应该返回 x,还是返回 y，并且不知道参数的具体生命周期，因此也不能保证返回的引用是否一定有效。为了修复这个错误，在 Rust 里面可以使用生命周期注解语法来解决：（下一页）生命周期注解不改变任何引用的生命周期的长短，它只是告诉编译器传给函数的引用的生命周期之间的关系，比如这里，就相当于跟编译器说，x， y 和返回值的生命周期是相同的，这样你就知道该怎么处理这些引用了吧？也就是说，生命周期注解相当于告诉编译器我传递给函数和函数返回的引用的生命周期应该有这样那样的关系，对于这段函数你就放心编译好了，如果我调用函数的时候不按这些规则传递参数，那时候你就报错就行了。  
好，关于所有权和生命周期这部分花的时间有点长了，接下来我们要抓紧时间了。  
正是得益于这种独特的内存管理模式，Rust 语言可以做到内存安全。而由于没有垃圾回收机制，Rust 语言可以做到极小的运行时，速度和 C/C++ 是一个级别的。  
Rust 语言除了在安全和性能上有优势外，它作为一门现代编程语言，还具有类型推导，泛型，支持函数式编程，包管理，卫生宏和过程宏等特性，顺便提一下在今年 Rust 将会稳定常量泛型特性。社区方面，在不断发展中。  

## Rust 语言与嵌入式
好了，说了那么多 Rust 语言，现在我们来聊一下为什么要用 Rust 语言来写嵌入式。  
我个人觉得 Rust 语言非常适合嵌入式开发，只要体现在以下几个方面：  
首先，Rust 的运行时很小，这就代表着有极高的性能，其次，前面提到的 Rust 语言的独特内存管理方式保证了内存安全，这两点是嵌入式软件开发的硬需。另外 Rust 语言的所有权机制非常契合嵌入式里面的外设抽象：我们的系统里面特定的外设同一时间只有一个，类似移动语义。  
Rust 语言的模块化和包管理在嵌入式开发里面相比 C 是一大优势，比如在嵌入式领域有个 HAL 库的概念，传统 C 语言开发的时候如果你要在自己的项目里面使用 HAL 库，你需要将一大堆源文件放到你自己的目录下，并且还有写 Makefile 对它进行管理。甚至有些时候很多开发板厂商不提供单独的 HAL 库，这样你就需要在官方提供的开发环境中进行开发。而在 Rust 语言里面，你只需在配置文件里面加上一行，就可以“导入”相关的第三方库，进而省去大量的项目维护成本，提高生产效率。  
其次 Rust 的宏系统非常强大，不同于 C 语言的宏是文本替换，Rust 的宏是语法树到语法树的替换，可以达到卫生宏的效果。由于时间关系这里就不多涉及。  
开发工具方面，Rust 支持多种指令集的交叉编译链，并且有工具统一管理。  
然后更让开发者欣喜的是 Rust 异步语法，比如 async/await 关键字，在裸机环境中也能得到支持。这样子我们写嵌入式程序的时候也能写异步代码，并且 await 关键字让我们像写同步代码一样去写异步代码。  
举个例子，UART 通信协议，在嵌入式领域它通常被认为是一种外设，我们通过 UART 进行串行数据传输。下面是一些不完整的代码：（陈述代码）  
接下来我想谈一下我对 Rust 嵌入式的生态的看法。首先这张图来自 Rust 嵌入式社区的资深贡献者，我的同学，洛佳。  
首先嵌入式硬件一般分为两部分，一个是处理核，比如平头哥的 C906/C910，还有 Sifive 的 U54/U74，另外一部分是外设，例如前面说到的 UART，除此之外还有 SPI，ADC 等等。处理核和外设合起来组成 SOC，这就很接近我们平常所说的开发板了，比如 k210。一个 SOC 平台的 Rust 嵌入式支持库大概有三个部分，第一个是外设访问库，这个库是可以通过给出相应板子的数据手册自动生成的;另外一个库是硬件抽象层库，在 Rust 嵌入式社区里面这个称为 embedded-hal 库，然后就是还有一些运行时库。  
外设访问库是机器生成的，里面主要是一些外设的结构体和方法，这里就不详细分析。我们先来看一下运行时库。  
运行时库这部分可以根据需求来实现，你可以写功能简单的最小运行时，也可以写能跑操作系统的复杂运行时。  
运行时库需要实现的功能主要是以下几个方面：  
首先，我们在硬件平台上运行裸机程序的时候，在运行第一行逻辑代码之前，我们需要进行一系列准备工作，这些准备工作主要是目标文件链接到指定内存地址上，设置中断入口点，提供默认的中断处理函数，跳转到逻辑代码入口。  
运行时库一般会提供一些过程宏，标记到某个函数，然后这个函数就作为逻辑代码入口点。  
可能大家这部分不能很好的理解，这里我简单的概括一下：在裸机环境上运行程序的时候，我们需要一些准备运行时环境的共性工作，而运行时库就帮我们完成了这部分工作。  
好了，运行时库的部分到这里告一段落，接下来我想介绍一下 Rust 嵌入式社区里面一个很重要的标准，叫做 embedded-hal 标准。  
什么是 embedded-hal 标准？这是 Rust 嵌入式社区的一个统一的标准，它是对外设本身的一系列抽象。这个标准对应着一个同名的库，这个库只是提供一系列的 trait,不涉及具体的实现。有些朋友可能不了解 trait 是什么，不妨把它看成是 Java 里面的接口，interface。具体的实现则由各个开发板的实现库来实现，比如 stm32f30x-hal,k210-hal。这种设计模式其实在 Rust 里面很常见，有了这个 embedded-hal 标准，我们就有了对嵌入式外设的统一的抽象，代码的移植性和可复用性由此可以得到提高。  
不知道各位还记不记得之前给出过的这个例子，这里我们引入一个 embedded-hal 的一个 serial trait,大家可以理解为 serial 接口，而 serial 是串行的意思，因此这是一个串行数据传输接口。而我们下面的代码就是为这个 UartLite 外设实现串行数据传输接口。如果各位有上过嵌入式开发的课程或者说接触过嵌入式相关的东西，就会知道外设数据传输有串行和并行方式，分别对应两种外设抽象。而这里我们实现的是串行抽象。  


## Rust 语言与 RISC-V 嵌入式
从开始到现在我的报告已经过去了_分钟了，感谢各位一直听到现在，接下来将进入最后一个环节：将 RISC-V 和 Rust 和嵌入式结合起来，以一个具体例子，来分析一下三者之间结合起来会有什么样的化学反应。  
首先我需要提一个 RISC-V 里面的 SBI 标准，这里我不会介绍这个标准具体细节，我想要说明的是这个标准设计的优秀之处。  
在 RISC-V 体系结构里面，从上到下分为 U, S, M 三层，分别运行着用户程序，操作系统内核，和 SBI 实现，注意，是 SBI 实现，SBI 只是一个标准，SBI 实现才是具体的软件。M 层以下就是各种硬件平台，包括模拟器和真实硬件。这种层级结构带来一个好处：如果我们想要移植一个操作系统到一个硬件平台的时候，我们只需要移植或者实现这个硬件平台的 SBI 实现，这样子操作系统内核就可以无障碍地移植到那个硬件平台上去。另外一种好处是：RISC-V 指令集版本目前还在不断迭代更新中，尽管每个版本的更改不会很大。指令集版本升级之后，可能会有些寄存器或者指令发生变化，这样就导致可能新指令集版本的软件不能兼容旧指令集版本的硬件。这时候，SBI 就派上用场了，我们可以在 SBI 实现里实现模拟指令运行，使得向下兼容指令集版本成为可能。这样一来就延长了硬件的生命周期。  
现在我来介绍一款软件，叫做 RustSBI，这是一个用 Rust 语言写的 SBI 实现。它适配 RISC-V 0.2 版本的 SBI 标准，目前支持 qemu 和 k210 平台，对类 Unix 操作系统内核有很好的支持。  
与 RustSBI 类似的实现是 OpenSBI，qemu 平台默认的 SBI 实现。  
RustSBI 一共 2000 多行代码，它实现了大部分 OpenSBI 中的功能，而 OpenSBI 一共 16000 多行代码。  
尽管 OpenSBI 适配的平台比 RustSBI 多，但除去平台相关代码 OpenSBI 的代码量仍然是远远高于 RustSBI 的，而且 RustSBI 的平台相关代码仅有几百行。RustSBI 用少量的代码达到了很好的效果，原因在于其依赖了一些第三方库，对 k210 的支持使用了 k210-hal 和 k210-pac 这两个嵌入式支持库，因此 RustSBI 的开发效率受益于 Rust 嵌入式生态。  
然后对于 k210 这块板子，它实现的指令集版本是 1.9 版本，而我们的编译链基本上都是 1.11 版本，这样子就会出现一些不兼容的地方，比如 sfence.vma 这条指令，在 k210 平台上是不存在的，但是它存在 sfence.vm 这条指令，因此我们可以在 SBI 实现里面模拟 sfence.vma 指令。  
从这个例子可以看到 SBI 的设计使得我们可以做到这种看起来不可思议的事情，并且我觉得这正是 RISC-V 架构软硬协同设计的一个很好的体现：硬件和软件互补。  
最后想要补充一点的是，RustSBI 是一个库，它本身不涉及具体实现，目前支持 qemu 和 k210 平台的代码是作者写的两个参考实现。事实上，如果我们需要将 RustSBI 适配一个新的硬件平台，只需要提供相应的 Rust 嵌入式支持库，即可很容易完成。这个得益于 Rust 语言模块化设计。  
我的演讲到此结束，谢谢各位。  

