<!-- PLCT 技术报告面试讲稿 -->

## RISC-V 生态
对于 RISC-V 生态，可能在座的各位都比我熟悉，尽管这样，我想先聊一下我对 RISC-V 生态的一些看法。  
RISC-V 架构诞生于伯克利，设计之初就定位为是一种完全开源的架构，基本指令仅有 40 多条，设计简洁，模块化设计使得用户可以根据需求自由定制，配置不同的扩展指令集。  
与 X86 架构进行对比，RISC-V 架构大大降低了芯片开发的难度，并且它吸收了一些传统指令集的经验教训，抛弃了历史包裹，设计更加简洁先进。但是在高性能处理核领域，RISC-V 目前还比不上 x86。  
与 Arm 架构进行对比，RISC-V 指令集完全开源，而 Arm 需要商业授权。RISC-V 推崇大道至简的设计，架构文档只有 200 多页，而 Arm 架构文档长达数千页。但是在生态上，还需要社区开发者们的进一步努力。  

我觉得相比于高性能处理核领域，RISC-V 更有可能在嵌入式领域赢得市场。  
去年 12 月 26 号，我去参加全国大学生操作系统比赛研讨会，在场下和一位国内某知名芯片厂商产品经理聊了一下在嵌入式行业内，目前 RISC-V 是什么样的情况。我问，RISC-V 对比 Arm 在性能和功耗方面有什么优势吗？没有。RISC-V 在嵌入式行业火吗？很火。那位先生说 RISC-V 带来的是一个新的产业模式，一个有可能打破 Arm 商业垄断的模式。  

## RISC-V 与嵌入式
好，现在我来说一下我觉得 RISC-V 在嵌入式领域里面有哪些优势，主要是对比 Arm 架构。  
首先，在性能与功耗上，同样的芯片面积和制作工艺下，RISC-V 和 Arm 不相上下。（给出数据）  
然后，在成本上，RISC-V 占据优势，具体表现为以下几个方面。一，RISC-V 的设计成本较低，得益于其简洁的设计风格。比如规整的指令结构，这样可以提高译码速度，还有简单的寄存器组成，等等。另外 RISC-V 是模块化的设计，某种程度上提高了可移植性和降低了维护成本。对于上面这句话，我个人感觉是这样，但还没有深入研究，如果各位在这方面有见解的话，欢迎提出或者指出错误。其次就是由于 RISC-V 的开源性，开发厂商可以省去一笔昂贵的版权费，同时能做到技术自主可控，我觉得这点在当前的国际大环境下特别重要。  
todo：软硬协同设计  
RISC-V 的 SBI 标准，使得移植运行在 S 态的操作系统到不同的平台，包括模拟器和硬件开发板，十分方便。关于 SBI 标准，后面会有环节来深入。现在我们先跳过。  

## Rust 语言
好，现在我们来聊一下 Rust 语言。  
可能有些同学对 Rust 语言不是很熟悉，我先来简单介绍一下这门语言的大致情况和为什么会有这门语言。  
Rust 语言是一门类似 C 的语言，它有编译期，编译生成可执行文件，并且它支持多个指令集的编译目标，比如 RISC-V。同时它的写法区别于 Java, C# 这样的完全面向对象的语言，它本身没有传统的类和对象，但有一些面向对象的特性，比如封装，即定义一个结构体，给这个结构体封装一些方法，再比如 trait 对象。  
Rust 语言被设计出来是为了解决内存安全问题，同时希望兼顾高性能。目前来说 Rust 这两者都做得比较好。  
基本上所有程序都需要管理和使用内存，在一些语言，比如 C/C++，依赖开发者亲自动手分配和释放内存;另一些语言，比如 Java,具有垃圾回收机制，在运行时中不断寻找不再使用的内存并释放掉。这两种方法各有千秋，但 Rust 语言采用的是另一种方法，那就是所有权和生命周期机制。  
所有权机制主要是指下面三条规则：一，Rust 里面每一个值都有一个被称为其所有者的变量;二，值在任一时刻有且仅有一个所有者;三，当所有者离开作用域，这个值将被丢弃。  
下面来看一段关于所有权的代码：（陈述代码）  
生命周期机制是 Rust 语言区别于其他大部分编程语言的一个概念，它主要是说明了这样一条规则：一个值的借用的生命周期不能长于该值本身的生命周期。也就是说，我们的借用不能指向一个已经被丢弃的值，这样就避免了类似 C 语言中裸指针的产生。  
下面是一段关于 Rust 中生命周期机制的代码：（陈述代码）  
或许上面这个例子还不足完整说明生命周期，我们再来看下一个例子，这段代码来自开源的 Rust 语言教程：（陈述代码）  
这个函数接收两个字符串引用参数，并返回长度较长的那个。这样的写法思路在 C/C++ 里面是完全没问题的，编译器甚至不会给出警告，而在 Rust 语言里面这段代码是无法编译的。原因在于在编译期中编译器不知道是应该返回 x,还是返回 y，并且不知道参数的具体生命周期，因此也不能保证返回的引用是否一定有效。为了修复这个错误，在 Rust 里面可以使用生命周期注解语法来解决：（下一页）生命周期注解不改变任何引用的生命周期的长短，它只是告诉编译器传给函数的引用的生命周期之间的关系，比如这里，就相当于跟编译器说，x， y 和返回值的生命周期是相同的，这样你就知道该怎么处理这些引用了吧？也就是说，生命周期注解相当于告诉编译器我传递给函数和函数返回的引用的生命周期应该有这样那样的关系，对于这段函数你就放心编译好了，如果我调用函数的时候不按这些规则传递参数，那时候你就报错就行了。  
好，关于所有权和生命周期这部分花的时间有点长了，接下来我们要抓紧时间了。  
正是得益于这种独特的内存管理模式，Rust 语言可以做到内存安全。而由于没有垃圾回收机制，Rust 语言可以做到极小的运行时，速度和 C/C++ 是一个级别的。  
Rust 语言除了在安全和性能上有优势外，它作为一门现代编程语言，还具有类型推导，泛型，支持函数式编程，包管理，卫生宏和过程宏等特性，顺便提一下在今年 Rust 将会稳定常量泛型特性。社区方面，在不断发展中。  

## Rust 语言与嵌入式
好了，说了那么多 Rust 语言，现在我们来聊一下为什么要用 Rust 语言来写嵌入式。  
我个人觉得 Rust 语言非常适合嵌入式开发，只要体现在以下几个方面：  
首先，Rust 的运行时很小，这就代表着有极高的性能，其次，前面提到的 Rust 语言的独特内存管理方式保证了内存安全，这两点是嵌入式软件开发的硬需。另外 Rust 语言的所有权机制非常契合嵌入式里面的外设抽象：我们的系统里面特定的外设同一时间只有一个，类似移动语义。  
Rust 语言的模块化和包管理在嵌入式开发里面相比 C 是一大优势，比如在嵌入式领域有个 HAL 库的概念，传统 C 语言开发的时候如果你要在自己的项目里面使用 HAL 库，你需要将一大堆源文件放到你自己的目录下，并且还有写 Makefile 对它进行管理。甚至有些时候很多开发板厂商不提供单独的 HAL 库，这样你就需要在官方提供的开发环境中进行开发。而在 Rust 语言里面，你只需在配置文件里面加上一行，就可以“导入”相关的第三方库，进而省去大量的项目维护成本，提高生产效率。  
其次 Rust 的宏系统非常强大，不同于 C 语言的宏是文本替换，Rust 的宏是语法树到语法树的替换，可以达到卫生宏的效果。由于时间关系这里就不多涉及。  
开发工具方面，Rust 支持多种指令集的交叉编译链，并且有工具统一管理。  
todo：异步

## Rust 语言与 RISC-V 嵌入式

